
# 풀이 과정

탐욕법(Greedy)을 사용하여 사람의 몸무게를 오름차순으로 정렬한 뒤,

가장 낮은 몸무게(첫번째 값)와 가장 높은 몸무게(마지막 값)을 더해서

```구명보트의 제한 몸무게보다 작거나 같다 == 두 사람을 동시에 탑승시킬 수 있다```

```구명보트의 제한 몸무게보다 크다 == 두 사람을 동시에 탑승시킬 수 없으니 더 무거운 사람만 탑승시킨다```

이미 구명보트에 탑승한 사람은 비교할 필요가 없으니, 그다음으로 무거운(그다음으로 가벼운) 몸무게 값을 선정하여

같은 방식으로 비교한다.

# 로직

값을 추가하고 제거하면 시간이 너무 오래 걸려, 투포인터를 사용하였다.

가장 무거운 사람이 탑승할 시에는 그다음으로 무거운 사람을 찾아야 하므로 ```우측 위치값 - 1```

가장 가벼운 사람이 탑승할 시에는 그다음으로 가벼운 사람을 찾아야 하므로 ```좌측 위치값 + 1```

|1|3|4|5|
|---|---|---|---|
|*| | |*|

여기서 구명보트의 제한 몸무게가 ```6```이라고 하면,

가장 가벼운 사람과 무거운 사람을 둘 다 태울 수 있으므로 (1 + 5 <= 6)

좌측 위치값을 +1, 우측 위치값을 -1 하면 다음과 같다.

|1|3|4|5|
|---|---|---|---|
| |*|*| |

여기서는 두 사람을 둘 다 태울 수 없으므로 (3 + 4 > 6)

무거운 사람만 탑승시킨다.

|1|3|4|5|
|---|---|---|---|
| |* *|| |

맨 마지막으로, 좌측 위치값과 우측 위치값이 같으므로 해당 플레이어를 탑승시킨다.

# 코드

```cpp
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

int solution(vector<int> people, int limit) {
    int answer = 0;
    
    sort(people.begin(), people.end());
    
    int left_key = 0;
    int right_key = people.size() - 1;
    
    while (left_key < right_key) {
        if (people[left_key] + people[right_key] <= limit) {
            left_key++;
        }
        right_key--;
        answer++;
    }
    
    if (left_key == right_key) {
        answer++;
    }
    
    return answer;
}
```
