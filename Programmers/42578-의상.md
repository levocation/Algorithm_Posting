문제에 나온 다음 표를 예로 들면

|종류|이름|
|------|---|
|얼굴|동그란 안경, 검정 선글라스|
|상의|파란색 티셔츠|
|하의|청바지|
|겉옷|긴 코트|

얼굴의 경우, ```2```개이므로, 이 중 하나를 골라서 입는(혹은 고르지 않는) 경우의 수는

|얼굴|
|----|
|     X |
|동그란 안경|
|검정 선글라스|

아무것도 입지 않는 경우의 수까지 포함하여
총 ```3```가지다.

마찬가지로, 특정 종류의 의상  ```n```개가 있을 때, 이 중 하나를 골라서 입는 경우의 수는 ```n + 1```개다.

여러 부위의 의상이 있으므로, 이는 경우의 수를 곱하여서 나타낼 수 있다. 따라서 경우의 수는 (표를 기준)

```(얼굴 의상 수 + 1) * (상의 의상 수 + 1) * (하의 의상 수 + 1) * (겉옷 의상 수 + 1)``` 가 된다.

반드시 의상을 하나 이상 입어야 하므로, 아무것도 입지 않는 경우의 수(1가지)를 제외하면

```(얼굴 의상 수 + 1) * (상의 의상 수 + 1) * (하의 의상 수 + 1) * (겉옷 의상 수 + 1) - 1``` 가 된다.

-----------------------------------------

입력값이 ```{의상 이름, 의상 종류}```이므로, 해시 자료구조를 이용하여 

```의상 종류```를 검색하여 종류별 의상의 개수를 모은 뒤, 해당 수치에 +1을 해준다.

이후 map을 순회하면서 모든 값을 곱하고, 아무것도 입지 않는 경우의 수인 1을 빼주면 된다.

```cpp
#include <string>
#include <vector>
#include <map>

using namespace std;

int solution(vector<vector<string>> clothes) {
    int answer = 1;
    // 값을 곱해야 하기 때문에 기본값은 1
    
    map<string, int> m;
    
    for (vector<string> v : clothes) {
        // vector 순회

        if (m.find(v[1]) == m.end()) {
            // map에 의상 종류가 존재하지 않으면

            m.insert({v[1], 2});
            // 값을 새로 추가하고 기본값은 2 (위의 풀이 참고)
        } else {
            // 값이 이미 존재하면

            m.find(v[1])->second++;
            // 값을 1 증가
        }
    }
    
    for (auto it = m.begin(); it != m.end(); it++) {
        // 반복자를 사용하여 map 전체를 순회
        // map은 기본적으로 값이 추가된 순서로 정렬이 아닌, 오름차순 정렬이지만
        // 모든 값을 곱할 것이기 때문에 정렬 순서는 상관 X

        answer *= (*it).second;
        // 여기서 it은 map<string, int>::iterator 이다.
        // 반복자를 통해 값을 역추적 하면 map<string, int>를 얻어낼 수 있고
        // 해당 값의 second(의상 개수 +1)를 answer에 곱해준다.
    }
    
    return --answer;
    // 아무것도 입지 않는 경우의 수인 1을 제거
}
```
