
# 풀이 과정

__순간이동에는 배터리가 소요되지 않는다__ 라는 전제가 있으므로,

같은 거리를 이동하더라도 순간이동을 제일 많이 하면, 이때 배터리 소모량이 최소가 된다.

거리를 7이라고 가정해보자.

이때 7은 ```((1) * 2) * 2 + 1```이라고 표현할 수 있고, 이때 배터리 소모량의 최솟값인 2가 정답이다.

즉, __어느 경우에 수에도, 맨 처음은 배터리를 1 소모__ 해서 한 칸 걸어가야 한다.

또한, 순간이동은 ``` * 2 ``` 로 나타낼 수 있으므로,

1부터 꾸준히 2를 곱하고, 필요한 순간에 ```1을 더하면서(순간이동을 하지 않고 이동)``` 거리에 숫자를 맞춰나간다.

이 과정에서 1의 개수만 카운팅하면 그게 정답이다.

그렇다면 __필요한 순간에 1을 더하는 것__ 은 어떻게 해야 할 까?

# 로직

고민을 하던 중 이런 생각이 들었다.

"역으로 생각하면, 2로 나누기 직전에 1이 더해져 있는 상황이라면 1을 뺀 후에 2로 나누고, 이를 반복하다 보면 1이 되겠네?"

"그럼 그동안 1의 개수를 세는 것과 별 다르지 않겠네?"

__"거리값을 2로 나누면서 나머지가 1일 때의 개수를 세면 되겠네?"__

```((1) * 2) * 2 + 1``` 이 수식을 ```((7 - 1) / 2) / 2 = 1``` 로 역산해나가는 것이다.


# 코드
```cpp
#include <iostream>
using namespace std;

int solution(int n)
{
    int ans = 1;
    
    while (n != 1) {
        if (n % 2 == 1) {
            n--;
            ans++;
        }
        n /= 2;
    }

    return ans;
}
```
