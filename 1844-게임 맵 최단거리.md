
# 풀이 과정

지나갈 수 있는 칸이 ```1```로 주어졌다는 점을 이용하여, BFS(너비 우선 탐색) 로직을 사용하여 $(0, 0)$ 부터 좌표 기준으로 상하좌우 1칸을 탐색하되,

그 중 맵을 벗어나지 않고, 탐색하는 칸의 숫자가 ```1```이어야 탐색한 것으로 인정한다.

이후 해당 칸에 ```이전 칸의 숫자 + 1``` 을 대입한다.

이를 반복하여 맵 끝부분인 ```(n, m)```을 탐색하게 되면, 그때 해당 칸의 숫자를 반환한다.

### 동작 방법을 나타내기 위한 위한 그림 설명

<img width="109" alt="image" src="https://github.com/levocation/Algorithm_Slack_Study/assets/42001961/c60d11d3-8d1d-4133-8054-6981c7458813">

위의 맵을 토대로 보자.

- 해당 칸이 맵 밖을 벗어나지 않고, 칸의 숫자가 1일 때, 이를 ```정상적인 칸```이라고 정의한다.

----------------------

좌표가 담긴 큐
|            |
|:------------:|
|(0, 0)|

현재 맵 배열
|1|0|1|1|1|
|--|--|--|--|--|
|**1**|**0**|**1**|**0**|**1**|
|**1**|**0**|**1**|**1**|**1**|
|**1**|**1**|**1**|**0**|**1**|
|**0**|**0**|**0**|**0**|**1**|

```(0, 0)```에서 상하좌우 1칸을 탐색했을 때, ```정상적인 칸```은 아랫칸인 ```(1, 0)``` 밖에 없으니 이를 큐에 넣는다.

따라서 ```(1, 0)```의 값은 ```이전 숫자(1) + 1``` 인 2가 된다.

-------------------------

좌표가 담긴 큐
|            |
|:------------:|
|(1, 0)|

현재 맵 배열
|1|0|1|1|1|
|--|--|--|--|--|
|**2**|**0**|**1**|**0**|**1**|
|**1**|**0**|**1**|**1**|**1**|
|**1**|**1**|**1**|**0**|**1**|
|**0**|**0**|**0**|**0**|**1**|

```(1, 0)```에서 상하좌우 1칸을 탐색했을 때, ```정상적인 칸```은 아랫칸인 ```(2, 0)``` 밖에 없으니 이를 큐에 넣는다.

따라서 ```(2, 0)```의 값은 ```이전 숫자(2) + 1``` 인 3이 된다.

이를 반복...

--------------------------

좌표가 담긴 큐
|            |
|:------------:|
|(3, 2)|

현재 맵 배열
|1|0|1|1|1|
|--|--|--|--|--|
|**2**|**0**|**1**|**0**|**1**|
|**3**|**0**|**1**|**1**|**1**|
|**4**|**5**|**6**|**0**|**1**|
|**0**|**0**|**0**|**0**|**1**|

```(3, 2)```에서 상하좌우 1칸을 탐색했을 때, ```정상적인 칸```은 윗칸인 ```(2, 2)``` 밖에 없으니 이를 큐에 넣는다.

따라서 ```(2, 2)```의 값은 ```이전 숫자(6) + 1``` 인 7이 된다.

-----------------------------

좌표가 담긴 큐
|            |
|:------------:|
|(2, 2)|

현재 맵 배열
|1|0|1|1|1|
|--|--|--|--|--|
|**2**|**0**|**1**|**0**|**1**|
|**3**|**0**|**7**|**1**|**1**|
|**4**|**5**|**6**|**0**|**1**|
|**0**|**0**|**0**|**0**|**1**|

```(2, 1)```에서 상하좌우 1칸을 탐색했을 때, ```정상적인 칸```은 윗칸인 ```(1, 2)``` 과 오른쪽 칸인 ```(2, 3)``` 이 있으니 이들을 큐에 넣는다.

따라서 ```(1, 2)``` 과 ```(2, 3)```의 값은 각각 ```이전 숫자(7) + 1``` 인 8이 된다.

-----------------------------

좌표가 담긴 큐
|            |
|:------------:|
|(1, 2)|
|(2, 3)|

현재 맵 배열
|1|0|1|1|1|
|--|--|--|--|--|
|**2**|**0**|**8**|**0**|**1**|
|**3**|**0**|**7**|**8**|**1**|
|**4**|**5**|**6**|**0**|**1**|
|**0**|**0**|**0**|**0**|**1**|

```(2, 3)```에서 상하좌우 1칸을 탐색했을 때, ```정상적인 칸```은 오른쪽 칸인 ```(2, 4)``` 밖에 없으니 이를 큐에 넣는다.

따라서 ```(2, 4)``` 의 값은 ```이전 숫자(8) + 1``` 인 9가 된다.

이를 반복...

-----------------------------

좌표가 담긴 큐
|            |
|:------------:|
|(0, 3)|
|(3, 4)|
|(1, 4)|

현재 맵 배열
|1|0|9|10|1|
|--|--|--|--|--|
|**2**|**0**|**8**|**0**|**10**|
|**3**|**0**|**7**|**8**|**9**|
|**4**|**5**|**6**|**0**|**10**|
|**0**|**0**|**0**|**0**|**1**|

```(1, 4)```에서 상하좌우 1칸을 탐색했을 때, ```정상적인 칸```은 윗칸인 ```(0, 4)``` 밖에 없으니 이를 큐에 넣는다.

따라서 ```(0, 4)``` 의 값은 ```이전 숫자(10) + 1``` 인 11이 된다.

-----------------------------

좌표가 담긴 큐
|            |
|:------------:|
|(0, 4)|
|(0, 3)|
|(3, 4)|

현재 맵 배열
|1|0|9|10|11|
|--|--|--|--|--|
|**2**|**0**|**8**|**0**|**10**|
|**3**|**0**|**7**|**8**|**9**|
|**4**|**5**|**6**|**0**|**10**|
|**0**|**0**|**0**|**0**|**1**|

```(3, 4)```에서 상하좌우 1칸을 탐색했을 때, ```정상적인 칸```은 아랫칸인 ```(4, 4)``` 밖에 없으니 이를 큐에 넣는다.

따라서 ```(4, 4)``` 의 값은 ```이전 숫자(10) + 1``` 인 11이 된다.

그리고 ```(4, 4)```는 우리가 찾고자 하는 도착지이므로 답은 ```11```이다.

# 코드

```cpp
#include <vector>
#include <queue>
#include <utility>

using namespace std;

int answer = 2147483647;

int solution(vector<vector<int>> maps)
{
    answer = 2147483647;
    
    queue<pair<int, pair<int, int>>> bfs;
    // pair<이전 숫자, pair<x, y>>
    
    bfs.push(make_pair(1, make_pair(0, 0)));
    // 플레이어는 항상 (0, 0)에서 시작
    
    int width = maps[0].size();
    int height = maps.size();
    
    pair<int, pair<int, int>> pos;
    // pair<이전 땅의 숫자, pair<x, y>>
    
    int x = 0, y = 0;
    while (true) {
        
        if (bfs.size() <= 0) {
            // 더 이상 탐색할 칸이 없는데 위치가 도착지점이 아닐 경우

            answer = -1;
            break;
        }
        
        pos = bfs.front();
        
        maps[pos.second.second][pos.second.first] = pos.first;
        
        x = pos.second.first;
        y = pos.second.second;
        
        bfs.pop();
        
        if (x >= width - 1 && y >= height - 1) {
            // 큐에서 꺼낸 좌푯값이 도착지점일 경우

            answer = maps[y][x];
            break;
        }
        
        if (x - 1 >= 0 && maps[y][x - 1] == 1) {
            bfs.push(make_pair(pos.first + 1, make_pair(x - 1, y)));
            maps[y][x - 1] = pos.first + 1;
        }
        if (x + 1 <= width - 1 && maps[y][x + 1] == 1) {
            bfs.push(make_pair(pos.first + 1, make_pair(x + 1, y)));
            maps[y][x + 1] = pos.first + 1;
        }
        if (y - 1 >= 0 && maps[y - 1][x] == 1) {
            bfs.push(make_pair(pos.first + 1, make_pair(x, y - 1)));
            maps[y - 1][x] = pos.first + 1;
        }
        if (y + 1 <= height - 1 && maps[y + 1][x] == 1) {
            bfs.push(make_pair(pos.first + 1, make_pair(x, y + 1)));
            maps[y + 1][x] = pos.first + 1;
        }
    }
    
    return answer;
}
```
