
가장 단순한 방법은 당연히

```cpp
long long fibo(long long n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    return (fibo(n - 1) % 1234567) + (fibo(n - 2) % 1234567);
}
```

재귀함수지만, 당연하게도 오버플로우가 발생할 것이다. (혹은 시간 초과)

그래서 동적 프로그래밍(Dynamic Programming, DP)를 사용하기로 했다.

```F(0) = 0``` 이고 ```F(1) = 1``` 이므로

이를 1차원 배열 dp로 바꾸면

```dp[0] = 0, dp[1] = 1``` 이 된다.

```F(n) = F(n-1) + F(n-2) (단, n >= 2)``` 이므로

```dp[n] = dp[n-1] + dp[n-2] (단, n >= 2)``` 와 같다.

결과값을 1234567로 나눈 나머지를 return해야 하는데, 여기서 한 가지 의문점이 들었다.

__"혹시나 dp[n-1] + dp[n-2] 가 오버플로우가 나면 어쩌지?"__

그래서 이것을 그나마 방지하기 위해 __dp[n]마다 1234567로 나눈 나머지값을 넣기로 했다.__

즉, ```dp[n] = (dp[n - 1] % 1234567) + (dp[n - 2] % 1234567) % 1234567```이 되는 것이다.

```
증명
A = q1 * m + r1;
B = q2 * m + r2;

(A + B) % m
= (q1 * m + r1 + q2 * m + r2) % m
= ((q1 + q2) * m + r1 + r2) % m .... ①

이때 % m은 나머지 연산이므로
(q1 + q2) * m 은 나머지 연산 과정에서 결국 0이 되어버린다.

따라서
① = (r1 + r2) % m

여기서 r1과 r2는 각각
r1 = A % m, r2 = B % m 이므로
(A + B) % m = ((A % m) + (B % m)) % m
```

```cpp
#include <string>
#include <vector>

using namespace std;

int solution(int n) {
    int answer = 0;
    
    int* dp = new int[1234567];
    
    for (int i = 0; i <= n; i++) {
        if (i == 0) {
            dp[i] = 0;
        } else if (i == 1) {
            dp[i] = 1;
        } else {
            dp[i] = (dp[i - 1] % 1234567) + (dp[i - 2] % 1234567) % 1234567;
        }
    }
    
    answer = dp[n] % 1234567;
    
    return answer;
}
```
